using System;
using MessagePack;
using Reloaded.Memory.Streams;
using Riders.Netplay.Messages.Reliable.Structs.Menu.Shared;

namespace Riders.Netplay.Messages.Reliable.Structs.Menu.Commands
{
    [MessagePackObject()]
    public struct CharaSelectSync : IMenuSynchronizationCommand, IEquatable<CharaSelectSync>
    {
        public Shared.MenuSynchronizationCommand GetCommandKind() => Shared.MenuSynchronizationCommand.CharaSelectSync;

        [Key(0)]
        public CharaSelectLoop[] Sync;

        public CharaSelectSync(CharaSelectLoop[] sync) => Sync = sync;

        public byte[] ToBytes() => MessagePackSerializer.Serialize(this);
        public static CharaSelectSync FromBytes(BufferedStreamReader reader) => Utilities.DesrializeMessagePack<CharaSelectSync>(reader);

        #region Autogenerated by R#
        public bool Equals(CharaSelectSync other)
        {
            if (Sync.Length == other.Sync.Length)
            {
                for (int x = 0; x < Sync.Length; x++)
                {
                    if (! Sync[x].Equals(other.Sync[x]))
                        return false;
                }

                return true;
            }

            return false;
        }

        public override bool Equals(object obj) => obj is CharaSelectSync other && Equals(other);
        public override int GetHashCode() => (Sync != null ? Sync.GetHashCode() : 0);
        #endregion
    }
}