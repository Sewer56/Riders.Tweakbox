using System;
using Riders.Netplay.Messages.Misc;
using Sewer56.BitStream;
using Sewer56.BitStream.Interfaces;

namespace Riders.Netplay.Messages.Reliable.Structs.Gameplay
{
    /// <summary>
    /// Informs the host of an individual attack.
    /// </summary>
    public struct SetAttack : Misc.Interfaces.IBitPackable<SetAttack>, IEquatable<SetAttack>
    {
        /// <summary>
        /// True if a value is set, else false.
        /// </summary>
        public bool IsValid;

        /// <summary>
        /// The target player to be attacked.
        /// </summary>
        public byte Target;

        public SetAttack(byte target)
        {
            IsValid = true;
            Target = target;
        }

        public SetAttack(bool isValid, byte target)
        {
            IsValid = isValid;
            Target = target;
        }

        /// <inheritdoc />
        public int GetSizeOfEntry() => Constants.PlayerCountBitfield.NumBits + 1;

        /// <inheritdoc />
        public SetAttack FromStream<T>(ref BitStream<T> stream) where T : IByteStream
        {
            var data = stream.Read<byte>(GetSizeOfEntry());
            bool valid = (data & 1) == 1;
            var target = (byte)(data >> 1);
            return new SetAttack(valid, target);
        }

        /// <inheritdoc />
        public void ToStream<T>(ref BitStream<T> stream) where T : IByteStream
        {
            var valid = IsValid ? 1 : 0;
            var targetShift = (Target << 1);
            var value = (byte)(targetShift | valid);
            stream.Write(value, GetSizeOfEntry());
        }

        #region Autogenerated by R#
        /// <inheritdoc />
        public bool Equals(SetAttack other)
        {
            return IsValid == other.IsValid && Target == other.Target;
        }

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            return obj is SetAttack other && Equals(other);
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            return HashCode.Combine(IsValid, Target);
        }
        #endregion
    }
}